{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww14520\viewh10100\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 %\{\
#Include <math.h>\
#include \'93calc.h\'94\
\
%\}\
\
\
/* Types */\
\
#union \{\
\
true		true;\
false		false;\
short		short;\
char		char;\
long		long;\
bool		bool;\
integer	int;\
double	double;\
float		float;\
uint		uint;\
short		short;\
long		long;\
float		float;\
\
\}\
\
\
/* Define our terminal symbols (tokens). This should match the lex file */\
/* We also define the type they represent */\
\
%token <val>  NUM\
%token <tptr> VAR FNCT\
%type <val> exp\
/*****TOKENS**********/\
\
%token DOUBLEQUOTE;\
%token EMPTYSTRING\
%token LINECOMMENT\
%token OPENCOMMENT\
%token ENDCOMMENT\
%token DOCUMENTATION\
%token IMPORT\
%token NAMESPACE\
%token DOUBLEQUESTIONOPERATOR\
%token BACKTICK\
%token FRONTTICK\
%token LBRACKET\
%token RBRACKET\
%left  	  PERIOD\
%left	  PLUS\
%left     MINUS\
%right  ASSIGNS\
%right  SHALLOWCOPY\
%left    DIVISION\
%left    MULTIPLY\
%left    MOD\
%left    INTEGERDIVISION\
%token HASHTAG\
%left     REMAINDER\
%left    SHIFTLEFT\
%left    SHIFTRIGHT\
\'93%left  ADDASIGN\
\'93%left\'94 MINUSASSIGN\
%left    DIVASSIGN\
%right  MULTASSIGN\
%token FACTORIAL\
%token EXPONENTIAL\
%token PERCENT\
%token  INCREMENT\
%token DECREMENT\
%token GT\
%token LT\
%token GTEQUALS\
%token LTEQUALS\
%token NOTEQUAL\
%token NUMERAL\
%token LETTERS\
%token CAPITALS\
%token CAMELCASEALPHABET\
%token STRING\
%token LETTERS\
%token VARIABLENAME\
%token TYPENAME\
%token TYPEOPERATOR\
%token ATOPERATOR\
%token LPAREN\
%token RPAREN\
%token RIGHTARROW\
%token LEFTARROW\
%token SMALLARROW\
%token SMALLLEFTARROW\
%token <true> TRUE\
%token <false> FALSE\
%token NOT\
%token ISTRUE\
%token ISFALSE\
%token AND\
%token XOR\
%token OR\
%token NOTOR\
%token NOTAND\
%token LIKE\
%token AMPERSANDOP\
%token BITWISEOR\
%token BITWISEAND\
%token BITWISEXOR\
%token BITWISENOT\
%token BOOLEANEQUALS\
%token COLONOPERATOR\
%token FLOOR\
%token CEILING\
%token ROUND\
%token RANDOM\
%token ALSO\
%token LENGTH\
%token ISLETTER\
%token ISDIGIT\
%token ISWHITESPACE\
%token ISUPPERCASE\
%token ISLOWERCASE\
%token TOUPPERCASE\
%token TOLOWERCASE\
%token PUBLIC\
%token PROTECTEDF\
%token INTERNAL\
%token PRIVATE\
%token PACKAGE\
%token FRIEND\
%token TRUST\
%token FUNCTION\
%token VIRTUAL\
%token CONST\
%token FLUX\
%token MVC\
%token MVCBINDING\
%token CONTROLLER\
%token MODEL\
%token VIEW\
%token TARGET\
%token TEMPLATEOPERATOR\
%token TYPEOF\
%token DEEP\
%token NEED\
%token WILDCARD\
%token RETURNStMT\
%token SYNCHRONIZED\
%token LOCK\
%token SPINLOCK\
%token SEMAPHORE\
%token MONITOR\
%token OPERATOR\
%token STRINGCOPYBYREF\
%token CLASS\
%token ENDLESS\
%token THROWS\
%token LBRACE\
%token RBRACE\
%token STREAM\
%token VOLATILE\
%token VARIABLEOPERATOR\
%token NEW\
%token GENERIC\
%token ATOM\
%token CONSTRUCTOR\
%token APPLICATION\
%token APPOPERATOR\
%token THIS\
%token SCOPEOPERATOR\
%token FOR\
%token SEMICOLON\
%token COMMA\
%token RELEASE\
%token RETAIN\
%token RETAIN\
%token AUTORELEASE\
%token GETENTITYPOOL\
%token POOLRUN\
%token FROMSTRING\
%token TOSTRING\
%token CONVERT\
%token PRINTBUG\
%token TRY\
%token CATCH\
%token FINALLY\
%token AWAIT\
%token LAST\
%token AUTOFILL\
%token TAG\
%token FROZEN\
%token THAW\
%token INLINE\
%token BYTECODE\
%token NULL\
%token AS\
%token GLOBAL\
%token WAIT\
%token SUCCESS\
%token TEXTS\
%token AUTO\
%token STATIC\
%token SEALED\
%token ASSERT\
%token FINAL\
%token CONCATOPERATOR\
%token ANTICONCATOPERATOR\
%token STRICT\
%token UNION\
%token REQUIRES\
%token SATISFIES\
%token SIZEOF\
%token <short> SHORT\
%token <char> CHAR\
%token <long> LONG\
%token <bool> BOOLEAN\
%token <int>   INTEGER\
%token <double> DOUBLE\
%token <float> FLOAT\
%token FIXED\
%token <uint>	UNSIGNEDINT\
%token <ushort>	UNSIGNEDSHORT\
%token <ulong>	UNSIGNEDLONG\
%token <ufloat>	UNSIGNEDFLOAT\
%token REGISTER\
%token	ENUM\
%toekn	EXTERN\
%token	ASSIGNER\
%token	CONTINUE\
%token	TYPEDEF\
%token 	EXP\
%token	ABS\
%token	IF\
%token	ELSE\
%token	ELSEIF\
%token	NOOP\
%token	RESIDUE\
%token	RESIDE\
%token LEAP\
%token ITERATOR\
%token IN\
%token RANGE\
%token	FOREACH\
%token	DO\
%token	WHILE\
%token	UNTIL\
%token	WHERE\
%token	SHORTWHILE\
%token	SHORTFOR\
%token 	DOUBLELEFTBRACE\
%token	DOUBLERIGHTBRACE\
%token	SWITCH\
%token	CASE\
%token	BREAK\
%token	EXIT\
%token	PASS\
%token	BRANCH\
%token	JUMP\
%token	IMPLEMENTS\
%token	EXTENDS\
%token	INTERFACE\
%token	ABSTRACTCLASS\
%token	ABSTRACT\
%token 	SUPER\
%token 	ISOPERATOR\
%token	ISNOTOPERATOR\
%token	ISNOTHINGOPERATOR\
%token 	INCLUSION\
%token	REFLECTION\
%token	ARRAYTYPEOPERATOR\
%token	DOUBLEARRAYTYPEOPERATOR\
%token	GETPROPERTY\
%token	SETPROPERTY\
%token	BASE\
%token	SHALL\
%token	EXTENDMETHOD\
%token	CALLER\
%token	RET\
%token	PROCEDURE\
%token	POINTEROPERATOR\
%token	OPERATOR\
%token	CALLBYREACTION\
%token	CAR\
%token	CDR\
%token 	PROMISE\
%token	FUTURES\
%token	BASE\
%token	TAIL\
%token	TIEOPERATOR\
%token	LIKEOPERATOR\
%token	LAMBDA\
%token	DELETE\
%rokwn 	FILTER\
%token	PIPEOPERATOR\
/*** Advanced Primitives****?\
\
%token COLLECTION\
%token HASHTABLE\
%token SET\
%token ARRAY\
%token ARRAYLIST\
%token LINKEDLIST\
%token DOUBLYLINKEDLIST\
%token DOUBLYLINKEDARRAYLIST\
%token VECTOR\
%token MAP\
%token MULTIMAP\
%token STRING\
%token OBJECT\
%token LIST\
%token BTREE\
%token NARYTREE\
%token TRIETREE\
%token REDBLACKTREE\
%token SPLAYTREE\
%token AVLTREE\
%token GRAPH\
%token DIRECTEDGRAPH\
%token SINGLEDIRECTIONGRAPH\
%token STACK\
%token QUEUE\
%token CIRCULARQUEUE\
%token CIRCULARLIST\
%token ENDCLASS\
/******SORT*********/\
\
%token BUBBLESEORT\
%token QUICKSORT\
%token MERGESORT\
%token TREETRAVERSAL\
%token BFS-TREE\
%token DFS-TREE\
%token BFS-GRAPH\
%token DFS-GRAPH\
%token DIJKSTRA\
%token ASTAR\
\
\
/*\
%right \'91=\'91\
%left \'91-\'91, \'91+\'92\
%left \'91*\'92 \'91/\'91\
%left NEG		/* negation-unary minus */\
%right \'91^\'92		/* Exponentiation\
*/\
\
/* Define the type of node our nonterminal symbols represent\
   The types refer to the union above. */\
\
/* %type <typefromunion>  nonterminal */\
\
\
%start program\
\
%start symbol\
\
/** exp: \'85.. | exp + exp \{ $$ = $1 + $3 \}  <\'97 $1 refers to exp one and $3 to exp 3. $$ refers to the semantics of the addition**/\
\
\
%%\
\
/* EBNF */\
\
/*\
stmt : var_decl | fun_decl\
	| expr \{ $$ = new \
\
EXAMPLE:\
\pard\pardeftab720\partightenfactor0

\f1\fs26 \cf0 \expnd0\expndtw0\kerning0
\
%\{\
#define YYSTYPE double\
#include <math.h>\
%\}\
\
/* BISON Declarations */\
%token NUM\
%left '-' '+'\
%left '*' '/'\
%left NEG     /* negation--unary minus */\
%right '^'    /* exponentiation        */\
\
/* Grammar follows */\
%%\
input:    /* EMPTYSTRING */\
        | input line\
;\
\
line:     '\\n'\
        | exp '\\n'  \{ printf ("\\t%.10g\\n", $1); \}\
;\
\
exp:      NUM                \{ $$ = $1;         \}\
        | exp '+' exp        \{ $$ = $1 + $3;    \}\
        | exp '-' exp        \{ $$ = $1 - $3;    \}\
        | exp '*' exp        \{ $$ = $1 * $3;    \}\
        | exp '/' exp        \{ $$ = $1 / $3;    \}\
        | '-' exp  %prec NEG \{ $$ = -$2;        \}\
        | exp '^' exp        \{ $$ = pow ($1, $3); \}\
        | '(' exp ')'        \{ $$ = $2;         \}\
;\
%%\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \kerning1\expnd0\expndtw0 */\
\
\
/*** BASE ***/\
\
start:	      /* EMPTYSTRING */\
	     | program\
;\
\
program:	package IMPORT root;		\
\
root::		sentence;					\{//save package name \}\
\
sentence: 	BACKTICK expression BACKTICK	\{ //add to compile_stack \}\
		|  expression					\{ //add to expression_stack \}\
		| expression_to_list expression		\{ //add to expression _stack \}\
;\
\
expression:	expression					\{ //add to expression_stack \}\
		| term						\{ //add tp expression_stack \}\
		| nmspc 					\{ //addd to namespace \}\
;\
\
term:		term | 		/*recursion*/			\
		sum |       	/*add*/			\{ //add to expression_stack \}\
		factor	|	/*multiply or divide */	\{ //add to expressoin_stack \}\
		math	|	/*unary math */		\{ //add to expression_stack \}\
		paran | 	/*paranetheses		\{//add to expression_stacl \}\
		array |		/* define an array */		\{// add to expression_stack \}\
		function | 	/* define a function */	\{// add to expression_stack \}\
		streamed |	/*define a stream  */		\{// add to expression_stack \}\
		instantiate_classs |	/* create a class? */       \{// add to expression_stack \}\
		embed   |	/* embed applications into this */   \{// add to expression_stack \}\
		this	   |	/* return this object */         \{// add to expression_stack \}\
		period	  |	/* period operator */         \{// add to expression_stack \}\
		control structures   |   /* control structures */   \{// add to expression_stack \}\
		where	   |	/* where clause for control structures */  \{// add to expression_stack \}\
		super	   |	/* class super class functions\
;\
period:	LBRACKET term RBRACKET  PERIOD	\{ //access object_stack return result \}\
		|	LBRACKET term RBRACKET       \{ //access array_stack return result \}\
\
;\
\
package:	PACKAGE STRING;			\{ ///mark package name defined earlier? \}\
import:	IMPORT STRING;				\{ / //perform import operation \'93\}\
nmspc:	NAMESPACE STRING LBRACKET term RBRACKET 	\{/*take note of namespace */ \}\
\
/** Arithmetic Operations***/\
\
sum:		NUMERAL PLUS NUMERAL		\{ $$ = $1 + $3 \} 	\
		|	NUMERAL MINUS NUMERAL	\{$$ =  $1 - $3 \}\
;\
\
factor	:	NUMERAL MULTIPLY NUMERAL 	\{ $$ = $1 * $3 \}\
		| NUMERAL  DIVISION NUMERAL 	\{ $$ = $1 / $3 \}\
;\
\
full_alphabet:				\{ /* regex for the full alphabet  *./\}\
word:					\{ /* mix of numbers and alphabet */\}\
\
\
math:		LPAREN binary_math\
		| unary_math\
		| math RPAREN\
		| arrows\
;\
\
binary_math:		NUMERAL binarithmeticop NUMERAL;\
\
unary_math:		unaryarithemeticop	NUMERAL;\
\
super_op:		INCREMENT | DECREMENT;\
\
binarithemeticop:		MOD				\{ $$ = $1 % $3\}\
			|	INTEGERDIVISION		\{$$ =  $1 / $3 \}\
			| 	REMAINDER		\
			|	SHIFTLEFT			\{ $$ = $1 << $3\}\
			|	SHIFTRIGHT			\{ $$ = $1 >> $3 \}\
			|	ASSIGNS			\{ $$ = $! = $3 \}\
			|	ADDASSIGN			\{ $$ = $1 += $3 \}\
			|	MINUSASSIGN		 \{ $$ = $1 -= $3 \}\
			|	DIVASSIGIN			\{ $$ = $! /= $3 \}\
;\
\
unary_math:		MINUS			\{ $$ = $1 * -1\}\
		|	FACTORIAL			\{ $$ = $1!\}\
		|	EXPONENTIAL		\{ /** perform exponential operation **/\}\
		|	PERCENT			\{ /** perform percent operation */\}\
		|	INCREMENT			\{ $$ = $1++\}\
		|	DECRMENT			\{ $$ = $1\'97 \}\
			\
\
;\
arrows:		LEFTARROW   		\{/*implement the arrow operators */\
		|	RIGHTARROW\
		|	SMALLARROW\
		|	SMALLLEFTARROW\
;\
\
boolean_operations:  variable name boolean_operators variable name \{//tempsave $1 and $3 \}\
\
boolean_operators:	ISTRUE		\{//   if ($1 == true) \}\
		|	ISFALSE		\{// if  ($1 == false)\}\
		| 	AND			\{//  bvalue = $1 && $3\}\
		|	OR			\{//  bvalue = $1 || $3\}\
		| 	XOR			\{//  bvalue = $1 XOR $3 \}\
		|	NOTOR		\{//  bvalue = !($1 || $3\}\
		| 	NOTAND		\{ // bvalue = !($1 && $3\}\
		|	LIKE			\
		|	BOOLEANEQUALS  \{ if ($1==3 \}\
;\
bitwise_operators:	AMPERSANDOP     \{ bitwiseop = $1 & $3 \}\
		|	BITWISEOR             \{bitwiseop = $1 | $3 \}\
		|	BITWISEXOR          \{bitwiseop = $1 ^ $3\}\
		|	BITWISENOT	\{bitwisop = !($1)\}\
;\
\
miscellaneous_ops:	FLOOR			\{ /** IMPLEMENT IN C */*/\
		|	CEILING\
		|	ROUNDS\
		|	RANDOM\
		|	ALSO\
		|	LENGTH\
		| 	ISLETTER\
		|  	ISDIGIT\
		|	ISWHITESPACE\
		|	ISUPPERCASE\
		| 	TOUPPERCASE\
		|	TOLOWERCASE\
;\
\
variable_name	datatype VARIABLEOPERATOR STRING;	\{ /* store variable name on stack */ \}\
\
camelcasealphabet   ;				\{ /* define camel case alphabet */\}\
\
/*** ARRAYS ****/\
\
array:			ARRAY ASSIGN LBRACKET  NUMERAL RBRACKET camelcasealphabet; \{ push onto array_stack \}\
\
access modifier:	PUBLIC 			\{push onto function modifier stack\}\
	|		PROTECTED	\{push onto function modifier stack\}\
	|		INTERNAL                  \{push onto function modifier stack\}\
	|		PRIVATE                  \{push onto function modifier stack\}\
	|		PACKAGE                  \{push onto function modifier stack\}\
	|		FRIEND                  \{push onto function modifier stack\}\
	|		TRUST                  \{push onto function modifier stack\}\
	|		FUNCTION                  \{push onto function modifier stack\}\
	|		virtual\
	|		CONST		                  \{push onto function modifier stack\}\
	|		mvc\
	|		mvcbinding\
	|		FLUX\
;\
\
mvc:			CONTROLLER	\{push onto mvc binding table\}\
	|		MODEL		\{push onto mvc binding table\}\
	|		VIEW			\{push onto mvc binding table\}\
\
mvcbinding:		classobject BIND classobject		\{push onto mvcbinding table\}\
;\
\
mvconewaybind:	classobject onewaybind classobject;	\{push onto mvcbinding table\}\
	\
/** restricting who is able to use the function */\
\
rtarget:		TARGET functionlist;\
functionlist:		functionname \
			| functionlist\
;\
\
/**** Function Code ****/\
\
function:		LBRACKET functionprelude functionheader functionbody RBRACKET; \{push onto function table stack\}	\
functionprelude:	OPERATOROVERLOAD accessmodifier synchronized EXPLICIT funcdatatype; \{push onto function table stack\}\
function header:	function name functionparams functionbody return;\{push onto function table stack\}\
functionparams:	need deepm constm     \{ push onto function table stack \}\
		|	functionparams            \{push onto function table stack\}\
		| 	functionnamedparameter  \{push onto function table stack \}\
;\
\
need:		empty | need;\
deepm:	empty | deep;\
constm	empty | const;\
\
funcdatatype:	datatype | datatype WILDCARD;\
functionbody:		term | function;\
return:			RETURN TUPLE 			\{ function table stack - return tuple \}\
		|	RETURN SET			\{ function table stack - return set\}\
		|	RETURN VARIABLE		\{function table stack - return variable \}\
		| 	RETURN NUMERAL		\{ function table stack - return numeral \}\
		|	RETURN CAMELCASEALPHABET \{function table stack - return word \}\
\
;\
\
synchronized:	empty | SYNCHRONIZED;\
\
functionnamedparameter:	datatype CAMELCASEALPHABET ASSIGNS CAMELCASEALPHABET\
functionparams:	functionaltparams COLON functionalaltparams;\
\
functionalalternateparams:	 functionaltparams | functionaltp;\
\
operatoroverload:	OPERATOR operator;\
\
operator:		\{//**** SEE OPERATORS ABOVE ***********\}\
\
/*** ASSIGNING FUNCTIONS TO VARIABLES***********/\
\
funcassign:		variable ASSIGNS functionnname;\
shallow copy:	variable SHALLOWCOPY functionname;\
\
/**EQUIV OF REFERENCE**************/\
\
stringcopy1:		datatype STRINGCOPYBYREF	datatype;\
\
/****EQUIV OF CONTENTS**************/\
\
stringcopy2:		datatype ASSIGNS datatype;\
\
/***STRING AS A BASE CLASS**********/\
\
booleanstring:	datatype ASSIGNS classname\
\
/****CALLING FUNCTIONS USING INFIX**********/\
\
infixheader:		accessmodifier SYNCHRONIZED EXPLICIT LPAREN functionname functionalparams RPAREN\
\
/*****COLON OPERATOR FOR COMPOSITION ********/\
\
colon:		functionname COLONOPERATOR functionheader\
		|	colonop2\
;\
\
colonop2:	functionname COLONOPERATOR functionname \
		|	functionname\
		|	colonop2\
;\
\
/***********FUNCTION CONCATENATION**************/\
\
concat:	functionname ATOPERATOR functionheader 	\
		| concat2\
;\
concat2:	functionname ATOPERATOR functionname\
		| functionname\
		| concat2\
;\
\
/***********VIRTUAL KEYWORD************************/\
\
virtual:	:	VIRTUAL;\
\
/***********DATATYPES****************/\
\
datatype:		primitivetype\
		|	customdatatype\
		|	GENERIC\
\
/************CLASS INITIALIZATION*************/		\
;\
class initialization:	typeconstructor classheader classbody ENDCLASS;\
type constructor :	STRING types;\
typeopp:		VARIABLE;\
typeop2:		VARIABLE  TYPEOPERATOR;	\
types:			RIGHTARROW TYPE;\
type:			CAMELCASEALPHABET | VOID | type;\
class header:		HASHTAG access modifier miscmodifiers CAMELCASEALPHABET  throws\
class body:		classfields | properties\
classifieds:		classifieds \
	|		members\
	|		function\
;\
members:		term;\
throws:		throws exception;\
miscmodifiers:	miscmodifieres\
	|		implements classtype\
	|		extends classtype\
implements:		IMPLEMENTS classtype | COMMA implements;\
extends:		EXTENDS classtype | COMMA extends;\
properties:		accessmodifiers datatype CAMELCASEALPHABET LBRACE getproperty RBRACE LBRACE  setproperty RBRACE;\
get property:		GETPROPERTY LBRACE members RBRACE;\
set property:		SETPROPERTY LBRACE members RBRACE;\
\
\
/******************INTERFACES****************/\
\
interfacebody:        function | interfaces;\
interfaces: 	         interface | interfaces\
interface:	         accessmodifier interfacebody \
\
/*****************MIXED IMPLEMENTS AND EXTENDS***************/\
\
mixed: 		interface oopclasses\
oopclasses:		extends \
		|	implements\
		|	 oopclasses\
;\
extends:		EXTENDS | extends;\
implements:		IMPLEMENT | implements;\
\
/********************TUPLES********************/\
\
tuple:			LPAREN tuple_content RPAREN;\
\
tuple_content:	CAMELCASEALPHABET\
		|	TUPLECOMMA, CAMELCASEALPHABET;\
;\
\
/******************STREAMS*********************/\
\
\
streamed:		STREAM streamletter ASSIGNS datatype;\
sreamletter:		char\
;\
/******************VARIABLES AND CLASSES************/\
\
instantiate:		classname volatile variable ASSIGNS NEW CLASSNAME typeinit;\
classname:		CAMELCASEALPHABET;\
volatile:		VOLATILE | empty;\
variable:		VARIABLEOPERATOR camelcase;\
 typeinit:		datatype | GENERIC\
variable:		CAMELCASEALPHABET\
\
/********************CREATION OF VARIABLES ON THE STREAM**************/\
\
class_definition:  volatile VARIABLEOPERATOR datatype streamletter camelcase typeinit;\
\
stream letter:     LPAREN letter RPAREN;\
\
/*********************ATOM*****************/\
\
atoms:		atom_definition\
atom_definition:	ATOM datatype atomname\
atom_name:		CAMELCASEALPHABET\
\
/*****************ADVANCED DATA TYPES*************/\
\
datatype:	matrix | vector;\
\
/******************ASSIGNMENT**********************/\
\
assignment:		variable ASSIGNS word\
\
/*******************ANNOTATIONS*****************/\
\
/******************ALTERNATE CONSTRUCTORS****************/\
\
alternate_constructors:	alternate_constructor | alternate_constructors;\
\
alternate_constructor:  LBRACKET accessmodifier CONSTRUCTOR construct_name acparameterlist acbody acreturn;\
\
construct_name:	CAMELCASEALPHABET;\
\
acparameterliste;	acname acdatatype | acparameterlist;\
\
acname:		CAMELCASEALPHABET;\
\
acdatatype:		datatype | datatype WILDCARD\
\
acbody:		term;\
\
ac return:		RETURN | tuple | variable;\
\
/***************EMBEDDING MULTIPLE APPLICATIONS INTO ONE***************************/\
\
embed:		ANNOTATION  APPLICATION ASSIGNS STRING;\
embeddable:		ANNOTATION WORD APPOPERATOR embeddablebody;\
\
/****************THIS COMMAND****************/\
\
this:		THIS;			\{ this; \}\
\
/*****************SCOPE OPERATOR*************/\
\
scope:		SCOPEOPERATOR;\
\
/****************RELATIONS********************/\
relations operator = GT | LT | BOOLEAN EQUALS | GTEQUALS | LTEQUALS | NOTEQUAL\
\
/***************SINGLE STATEMENT FOR LOOP**********/\
\
forone: FOR LPAREN datatype variable SEMICOLON relation SEMICOLON superop RPAREN singleitembracket;\
super: 	INCREMENT | DECREMENT | ADDASSIGN | MINUS ASSIGN | DIVASSIGN | MULTASSIGN;\
\
/**************BRACKET TWO OR MORE COMMANDS*************/\
\
singleitembrackets:	LBRACKET bracket terms RBRACKET\
innnerbracketterms: term COMMA bracket term term;\
bracketterm:		bracketterm COMMA term;\
\
/**************NESTED BRACES FOR LOOP *******************/\
\
multinestedbrackets:  FOR LPAREN datatype variable SEMICOLON relation SEMICOLON SUPEROP RPAREN NESTED;\
\
nested: 	nested | LBRACKET content RIGHTBRACKET;\
content:	nested | term;\
/***************STANDARD NOTATION FOR LOOP *************/\
\
standardfor:	FOR LPAREN datatype variablename SEMICOILON relation SEMICOLON SUPEROP cont;\
cont:		RPAREN LBRACKET term RBRACKET\
\
/****************MORE LOOP NOTATION**********************/\
\
/***************FOR EACH BASED LOOPS********************/\
\
foreachiter:	FOREACH LPAREN datatype ITERATOR variable term;\
foreachshort:	LPAREN datatype RPAREN term\
\
\
/****************MEMORY MANAGEMENT*********************/\
\
\
release:	RELEASE;\
\
retain:		RETAIN;\
\
autorelease:	AUTORELEASE;\
\
getentitypool:	GETENTITYPOOL;\
\
\
entitypool : LEFTBRACKET VARIABLENAME EQUALS GETENTITYPOOL\
\
poolrun: POOLRUN\
\
fromString : CLASSNAME variable EQUALSOP, \'93fromString\'94\
\
toString : FUNCTIONNAME, \'91toString\'92\
\
convert : CLASSTYPE EQUALSOP \'93convert\'94\
\
/******************MESSAGE PASSING**************************/\
\
\
/**\
[function definition] [ variable definition ]\
*/\
\
pass_function_message: 	LBRACKET functioncontents  RBRACKET;\
pass_variable_message:	LBRACKET variable contents RBRACKET;\
\
function contents:	functionname COLON destination;\
variable contents:	variablename COLON destination;\
\
destination:	variablename | functionname;\
\
/* debug statement */\
\
print_bug:	PRINTBUG LPAREN CONDITIONAL COMMA message RPAREN;\
message: 	word;\
\
/** TRY CATCH FINALLY */\
\
try_catch:	TRY CATCH exceptions trycode FINALLY finally_code;\
exceptions: 	exception | exceptions;\
exception:	exception_type variablename\
exception_type:	classname variablename\
try_code:	try_code\
	|	term\
	|	AWAIT\
;\
\
finallycode:	term;\
\
/* last */\
\
last:	LAST;\
\
autofill:	AUTOFILL classname variable name term;\
\
\
/* TRY CATCH WITH TAG COMMAND */\
\
tag string:	classname  variable name BOOLEANEQUALS function name;\
\
/*** MULTICATCH*****?\
\
multi catch:	TAG LPAREN multi exceptions RPAREN term;\
multi exceptions:	multi exceptions | exceptions\
\
/*****CHAIN CATCH **********/\
\
chain tag:	LPAREN TAG classname RPAREN  | chain tag;\
\
/*******Dynamic Tagging versus Static Typing ***********/\
\
frozen:	LPAREN FROZEN  LPAREN classname RPAREN RPAREN;\
thaw:		LPAREN THAW LPAREN classname	RPAREN	RPAREN;\
\
assert:	ASSERT LPAREN term RPAREN;\
inline:		INLINE assemblycode;\
bytecode:	BYTECODE bytecode;\
\
null:		NULL;\
\
\
/***********AS***********************//\
\
as:	AS module_name;\
module name:	word;\
\
\
/************lambda - anonymous function*************/\
\
lambda function:	LBRACKET lambdaheader lambdabody RBRACKET;\
lambda header:	access modifier LAMBDA lambdaparams RETURN;\
lambdaparams:	LAMBDA funcdatatypelambdabodyl | lambdaparams;\
l\
lambdadatatype:	datatype | datatype WILDCARD\
lambda body:		term\
\
/***************global**************************//\
//global variable across codeE\
global:		GLOBAL variablename\
\
/************Delete object***********************//\
delobject:	DELETE variablename;\
\
/**********commandExecute*****************/\
\
/***********goto*****************************/\
\
\
/***************True and false************/\
true: TRUE;\
false: FALSE;\
\
/**********WAIT********************/\
\
wait_operator:	WAIT LPAREN relation RPAREN;\
\
/******ON SUCCESS*******************/\
\
onsuccess:	LBRACKET function name SUCCESS functionanme RBRACKET\
\
\
\
/***********THROW*********************/\
\
throwstmt: 	THROW exception\
\
/**************TEXT LITERAL************/\
\
textliteral:	TEXTS word;\
\
\
\
/**********LOCK KEYWORD**************/\
\
lock_keywd:	LOCK LPAREN variable name RPAREN LBRAKCET term RBRACKET; ;\
\
\
\
\
\
/*********AUTO*****************/\
\
auto:	AUTO variablename;\
\
/*************SEALED*********************/\
\
sealed:	SEALED classname\
\
/*************STATIC KEYWORD*************/\
\
statickywre:	STATIC function | STATIC variablename;\
\
/************ASSERT******************?\
\
ASSERT := \'91assert\'92, LPAREN, relation, RPAREN;\
\
\
assert:	ASSERT LPAREN relation RPAREN\
;\
/**************Final**********************\
\
\
final:	FINAL variable name ASSIGNS word;\
\
/**************Double Question Operator***********/\
\
\
nullop:	variablename DOUBLEQUESTIONOPERATOR;\
\
/****************String Concatenation ***************/\
\
\
stringconcat:		word CONCATOPERATOR word;\
stringanticoncat:	word ANTICONCAT word;\
\
/**************Struct*****************************/\
*\
*     struct myStruct \{\
*   	Integer m\
*	Integer n\
*	String myString\
*        \}\
*/\
struct:	STRUCT structname LBRACKET structbody RBRACKET;\
structname:	word;\
structbody:	structbody | classname variablename;\
ARIABLENAME\
\
/************** UNION ***********************/\
\
union:	UNION unionsname LBRACKET unionbody RBRAKET\
unions name: 	word;\
unionbody:	unionbody | classname variablename;\
\
\
/**************REQUIRES AND SATISFIES*************/\
\
\
requires: 	REQUIRES;\
satisfies:	SATISFIES;\
\
\
\
/***************SIZEOF**************************/\
\
sizeof:	SIZEOF LPAREN variablename RPAREN;\
\
/****************************************************/\
/****************************************************/\
/**************\'94primitives(datatypes)\'94**************************/\
\
/***classs***/\
\
\
\
primitive type: 	SHORT | CHAR | LONG | BOOLEAN | INTEGER | DOUBLE | FLOAT | FIXED | \
			UINT | USHORT | ULONG | REGISTER;\
\
/***********************extern****************/\
\
extern:	word;\
\
\
/***********************Enum****************]\
\
enum: ENUM word ASSIGNS LBRACKET enums RBRACKET\
\
enums: word | enums;\
\
/**************Assigner*******************/\
\
assigner: ASSIGNER word ASSIGNS LBRACKET agn RBRACKET\
age: ASSIGNS | word ASSIGNS word\
\
/*********CONTINUE*******************/\
\
continue: CONTINUE;\
\
/**********Typedef**********************/\
\
typedef: TYPEDEF classname word;\
\
/******** EXP***********************/\
\
exp: EXP LPAREN numeral COMMA numeral RPAREN;\
\
/*********ABS**********************/\
\
ABS := \'91Abs\'92, LPAREN, NUMERAL, RPAREN\
\
abs:  ABS LAPREN numeral RPAREN\
\
\
\
/*******EXTRA MATHOPS********************/\
\
math\'92s:       unarymathops | binarymathops | twotermsopone, twotermsoptwo\
\
unarymathopds: EXPOENTIAL | MINUS | PLUS | PERCENT | FACTORIAL | INCREMENT  			| DECREMENT | BACKTICK | FRONTTICK | ENDCLASS | ABS | CAR | CDR\
\
binarymathops:  PLUS | MULTIPLY | MINUS | DIVISION | INTEGERDIVISION | MOD | REMAINDER |\
					SHIFTLEFT | SHIFTRIGHT | ASSIGNS | BOOLEANEQUALS | LT\
					| GT | LTEQUALS | GTEQUALS |\
					NOTEQUAL | ADDASIGN | MINUSASSIGN | DIVASSIGN |\
					MULTASSIGN | PERIOD | COMMA | EXP\
\
/***not sure what this is supposed to do**/\
twotermsopone : LBRACKET\
twotermsoptwo : RBRACKET\
\
\
\
\
\
\
/********************CONTROL STRUCTURES********************/\
\
\
control_structures:	 ifelse \
		downhil\
		l | where\
		 | until \
		| for iterative\
		 | foreach \
		| foreachshort \
		| forbuiltin \
		| listcomprehensions\
		| shorter\
		| shorwhile\
;\
\
\
\
ifelse: 	IF relation LBRACKET term RBRACKET elsemaybe;\
\
else maybe:	elsemaybe | ELSE LBRACKET tern RBRACKET | emptytring;\
\
downhill: 	DO LBRACKET term RBRAKET WHILE relation;\
\
where:	emptysring | RELATION FUNCTION;\
\
until:		DO LBRACKET term RBRACKET UNTIL relation\
\
\
foriterative:	FOR LPAREN instantiate SEMICOLON relation SEMICOLON relation RPAREN forbrackets;\
for brackets:	LBRACKET term residue  RBRACKET;\
\
residue:	EMPTYSTRING | RESIDUE;\
\
reside:	variable name | ASSIGN | RESIDE\
\
foreach:	FOR LPAREN classname variablename COLON variablename RPAREN LBRACKET | foreachobjs | RBRACKET;\
forecahobjs:	leap | resolve | foreachobjs;\
\
leap:		LEAP | EMPTYSTRING;\
resolve:	RESOLVE | EMPTYSTRING;\
\
\
\
\
foreachshort:		FOREACH variable name LBRACKET term RBRACKET;\
\
forbuiltin:		FOR LPAREN ITERATOR classname RPAREN LBRACKET term RBRACKET;\
\
\
listcomprehnsions:	LBRACKET FOR variable name IN RANGE LPAREN morelistcomphrension;\
morelistcomprehension:	FOR variable name IN RANGE LPAREN numeral RPAREN RBRACKET;\
\
shofrtfor:		FOR LPAREN relations operator numeral RPAREN LBRACKET term RBRAKET;\
				\
\
shortwhile:		WHILE LPAREN relation RPAREN LBRACKET term RBRACKET;\
\
router:			ROUTER relation COLON functionname;\
\
\
/************* SWITCH STATEMENT**********/\
\
switched:	SWITCH variable name LBRACKET cases;\
\
cases:		case_block | cases;\
\
case_block:	CASE LPAREN variable name RPAREN term exit | pass | BREAK;\
\
shortswitch:	SWITCH LPAREN variable name RPAREN switch_cases;\
\
\
switch cases:	LBRACKET RELATION numeral RBRACKET RETURN;\
\
\
break: 	BREAK;\
exit:		EXIT;\
pass:		PASS;\
branch:	BRANCH label;\
label:		word;\
jump:		JUMP word;\
\
\
\
/***************************LIST COMPREHNSIONS*****************/\
\
\
\
listcomprehension = LBRACKET INTEGER FOR variable name IN variable name IF RELATION RBRACKET;\
filter:	FILTER variablename | classname PIPEOPERATOR  classname | variablenamae;\
\
\
\
/*******************CLASSES************************]/\
\
anoninnerclass:	variable name LPAREN NEW CLASS LBRACKET \
\
\
ANONINNERCLASS:= VARIABLENAME LPAREN NEW CLASS LBRACKET term RBRACKET RPAREN;\
\
/***indexers****/\
\
indexingintoclass:	classname indexer;\
\
indexer: LBRACKET word RBRACKET | indexer;\
\
INDEXER := LBRACKET field RBRACKET | INDEXER\
\
interclass:	CLASS classname classheader LBRACE  classbody RBACE;\
\
\
/*** NO BOXING***/\
\
unboxing:	PRIMITIVE_TYPE ASSIGNS PRIMITIVE_TYPE;\
\
/***** OBJECT OPERATORS********/\
\
isoperator:	variablename IS variablename;\
\
isnotoperator: variablename ISNOT variablename;\
\
isnothing: variable name ISNOTHING;\
\
typeof:	variablename  TYPEOF classname;\
\
GET TYPE := RETURN classname;\
\
\
/**********MetaClasss***********/\
/**********EntityPool*************/\
\
metaclass:	classname GETENTITYPOOL;\
\
\
/************Categories***************/\
\
category:	PACKAGE LES\
\
CATEGORY	:= PACKAGE LEFTARROW |  function name;\
\
/************PROTOTYPE INHERITANCE************/\
\
PROTOTYPEINHERITANCE := INHERIT variablename variablename;\
\
\
/**************EXPRESSION BODY METHODS***********/\
\
\
EXPRESSIONBODYMETHODS := POOL RIGHTARROW VARIABLENAME RIGHTARROW LBRACE TERMS RBRACE\
\
expressionbodymethods = GETENTITYPOOL RIGHTARROW variablename RIGHTARROW LBRACE term RBACE;\
\
\
\
/*****Abstract Methods has no implementation */\
\
abstract:	ABSTRACT FUNCTIONHEADER\
\
/******Constructor keyword*********/\
\
constructor:  CONSTRUCTOR ACCESSMODIFIER classname   function header term;\
\
/*********Type Constructor**********./\
\
typeconstruct:       type construct | SMALLARRROW classname;\
\
/*********Data Construcetor*********./\
\
dataconstruct: classname function header;\
\
\
\
**********SUPER*********/\
super = SUPER;\
\
/******STRING HEIRACHY*********/\
\
hierarchystring: classname TYPEOPERATOR VARIABLEOPERATOR variablename ASSIGNS word;\
UE\
\
/********Iteratorse*******************/\
\
\
iteratorkeyword:	LT ITERATOR RT itername ASSIGNS classname;\
itername:		term;\
\
\
forloopwithiterator:	FOR LPARENT itername RPAREN functionbody;\
\
/********is operator*************.\
\
ISOP:    variable name IS classname;\
\
/*******inclusion keyword*********/\
\
inclusion keyword:	INCLUSION variable name ASSIGNS term;\
\
s/********AUTO PROPERTY FEATURE************/\
\
autopropertyget:     accessmodifier classname LBRACE GETPROPERTY SEMICOLON RBRACE autobheavior;\
authobehavior:	classname LBRACE listterms;\
listterms:		DOUBLEQUOTES variable name DOUBLEQUOTE | listterms;\
\
\
/**************TYPE SAFETY FOR FUNCTIONS**********/\
\
functiontypeconstructor:	parametertypes;\
parameter types:		parameter type | parameter types SMALLRIGHTARROW;\
\
/********REFLECTION**********/\
\
reflection: 	\
\
reflection: REFLECTION variable name ASSIGNS classname;\
\
\
\
\
 /********CHAINING DATATYPES**********/\
\
\
datatypechain := datatypechain, datatypeop;\
generic_type := datatypechain variable name ASSIGNS datatypechain;\
anon type := \'91<, word, \'91>\'92\
\
\
/*************MULTIPLE STATEMENTS ON ONE LINE*************/\
\
\
multiform : term term | \'91,\'92multiform\
\
/***********ARRAYS************/\
\
\
array:		ARRY  LBRACKET NUMERAL RBRACKET TYPEOPERATOR variablename ASSIGNS lbracedlist;\
\
bracedliset:	LBRACE blist RBRACE\
bracedlist:	bl | bracedlist;\
blist:		word     PERIOD | word;\
\
getfromlist:	variablename LBRACKET numeral RBRACKET;\
\
bracketed list:	LBRACKET brack RBRACACKET\
back:			br | bracketlist;\
br:			word  \
\
\
/**************STORING CODE IN AN ARRAY***************/\
\
CODEINANYARRAY := LBRACKET  NUMERAL RBRACKET TERMS\
\
codeinanyarray:	LBRACKET numeral RBRACKET term;\
\
/*************MULTIDIMENSIONAL ARRAYS****************/\
\
arraytypeidentifier: ARRAYTYPEOPERATOR;\
arraydoubletyped DOUBLETYPEOPERATOR;\
\
\
ARRAYTYPE := ARRAYTYPEIDENTIFIER VARIABLENAME EQUALSOP ARRAYTYPEIDENTIFIER\
array type:	arrraytypeidentifier variable name ASSIGNS arraytypeidentifier;\
doubletype:: arraydoubletyped variable name ASSIGNS  arraydoubletyped;\
\
/****************OBLONG ARRAY***************************/\
\
/******FIRST, USING A FOR LOOP******************/\
\
oblong array: ARRAY LBRACKET RBRACKET ASSIGNS NEW classname LBRACKET RBRACKET;\
\
/**********SECOND, DIRECT INSTANTIATION\
\
OBLONG DIRECT :-= ARRAYNAME EQUALS NEW TYPEOPERATOR DOUBLEARRAY\
DOUBLEARRAY := LBRACKET NUMERAL RBRACKET LBRACKET NUNMERAL RIGHTBRACKET\
\
\
oblongdirect: ARRAY ASSIGNS NEW TYPEOPERATOR arraydoubletyped;\
doublearray;  LBRACKET NUMERAL RBRACKET LBRACKET numeral RBRACKET;\
\
\
\
\
**************INDEXERS****************/\
/********USE [] NOTATION ON A CLASS ITSELF\
\
indexer: acessmodifier THIS LBRACKET RBRACKET  ASSIGNS NEW numeral properties;\
properties: GETPROPERTY FUNCTION | SETPROPERTY FUNCTION;\
\
\
\
/***********PRIMARY CONSTRUCTORS ON CLASSESE*********/\
\
PRIMARY CONSTRUCTOR := CLASSNAME, CLASSTYPE,  PARAMS\
\
primary_constructor:	classname, params;\
params:		variablename | COMMA VARIABLENAAME;\
\
/*********BASE KEYWORD**********/\
\
function_name ASSIGNS 	BASE;\
variable_name ASSIGNS   BASE;\
\
/*********NEW KEYWORD**************/\
\
/*****NEW INSTANTIATING MEMORY ON THE HEAP*********/\
\
new:	classname  TYPEOPERATOR variable name ASSIGNS NEW classname; \
\
  /*******NEW HIDING AN INHERITE MEMBER FROM A BASE CLASS*************/\
\
hide:	NEW variable name;\
\
//***********NEW - RESTRICTING DATA TYPES THAT MAY BE USED AS ARGUMENTS OFR \
//**A TYPE PARAMETER******/\
\
restrict_new:	variable name NEW classname;\
\
/************TUPLES*************/\
\
\
/***************SETS**************/\
\
\
/*************NESTED TYPES*************/\
\
\
nested_types:	nested_type | nested_types;\
nested_type:		classname |  classname SMALLARROW \
\
/**************CROSS TYPING*************/\
\
\
cross_types;	classname variable name word;\
\
\
/********SHALL KEYWORD**************/\
\
\
shall:	classname TYPEOPERATOR variable name SHALL variable name\
\
/*********EXTENSION METHODS********/\
\
extension_method::	classname EXTENDMETHOD FUNCTION;\
\
\
\
/**********CALLER FEATURES*************/\
caller_feature:	function header COMMA CALLER caller_types;\
caller_types:		caller_class | caller_types;\
caller_class:		classname | classname COMMA;\
\
\
/************MULTIPLE RETURN VALUES*********/\
MULTIPLERETURN := \'91ret\'92, LPAREN, MRETURNVALUES RPAREN\
MRETURNVALUE := DATATYPE VARIABLENAME | , MRETURNVALUE\
\
multiple_return:	RET LPAREN mreturnvalues RPAREN;\
mreturnvalues:	classname variablename | COMMA mreturnvalues;\
\
\
\
\
/********PROCEDURE KEYWORD*********/\
\
\
procedure:	LBRACKET proc_header procbody RBACKET;\
proc_header: procname  accessmodifier SYNCHRONIZEFD EXPLICI proc_params;\
proc_params:   paramname  variablename | proc_params;\
proc_name: word;\
paramname: word;\
procbody:	term; \
\
\
synchronized:	SYNCHRONIZED | EMPTYSTRING;\
\
/** synchronized causes function to take hold of a mutex while this function executes*/\
\
\
\
\
/****************Not so messy pointers********/\
\
pointers:	variable name ASSIGNS ADDRESSOFOPERATOR variable name;\
deref:		ASTERISKS variablename ;\
\
\
\
\
/**************CUSTOM OPERATORS************/\
\
customer:	access modifier OPERATOR LPAREN letter RPAREN FUNCTIONBODY;\
\
/****************CALL BY REACTION*************/\
					\
callbyreaction:	LBRACKET CALLBYREACTION RELATION FUNCTIONBODY;\
\
\pard\pardeftab720\ri720\partightenfactor0
\cf0 \
/******************CAR AND CDR*******************/\
\
CAR := car VARIABLE | car FUNCTION | CAR\
\
car:	CAR variablename | CAR FUNCTION  | CAR\
\
\
car:	CDR variablename | CDR FUNCTION | CDR\
car := CDR VARIABLE | CAR FUNCTION | CDR\
\
/***************PROMISES***************/\
\
promise:	variablename PROMISE variablename;\
\
/*****************FUTURES**************/\
\
futures: variablename FUTURE variablename;\
\
/*****************BUILT IN RECURSION********/\
\
basecur; 	BASE ASSIGNS FUNCTIONBODY;\
tailcur:		TAIL ASSIGNS FUNCTIONBODY;\
\
\
/******************STATEFUL******************/\
\
STAGEFUL :=       STAGEFUL VARB \'92tie\'92 OPERATOR\
VARB		:=     VARIABLENAME EQUALS VARIABLENAME\
 			| VARIABLENAME | VARB\
\
stateful:		STATEFUL varb  TIEOPERATOR \
varb:			variablename ASSINGS variablename\
			|  variablename\
			|  varb;\
\
/**********************LIKE OPERATOR AND REGEX***********/\
\
likeop:			variable name LIKE regexstring;\
regexstring:		word;\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\
}